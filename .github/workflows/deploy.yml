name: Simple DevOps CI/CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Build and Push
      run: |
        docker build -t group6acr.azurecr.io/devops-advisor:latest .
        az acr login --name group6acr
        docker push group6acr.azurecr.io/devops-advisor:latest
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
    
    - name: Terraform Apply
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      run: |
        set -e
        # Extract values from AZURE_CREDENTIALS and export as ARM variables
        export ARM_CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
        export ARM_CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
        export ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
        export ARM_TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
        export TF_IN_AUTOMATION=true
        export TF_INPUT=false
        export TF_LOCK_TIMEOUT=5m
        
        # Run Terraform with optimizations for speed
        cd terraform
        terraform init -upgrade
        
        # Apply changes only (no destroy)
        terraform apply -auto-approve -parallelism=20 -refresh=false -lock=false \
          -var="ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID" \
          -var="resource_group_name=rg-devops-group6" \
          -var="resource_group_location=polandcentral" \
          -var="resource_prefix=devopsa" \
          -var="environment=dev" \
          -var="managed_disk_name=app-data" \
          -var="disk_size_gb=20" \
          -var="storage_account_type=Standard_LRS" \
          -var="author=group6"
    
    - name: Setup AKS
      run: |
        az aks get-credentials --resource-group rg-devops-group6 --name devopsa-aks
        az aks update -n devopsa-aks -g rg-devops-group6 --attach-acr group6acr
    
    - name: Setup Helm (for ingress and monitoring)
      uses: azure/setup-helm@v4

    - name: Install ingress-nginx via Helm (idempotent)
      run: |
        set -e
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx || true
        helm repo update
        # Install/upgrade NGINX Ingress Controller; safe to re-run
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --set controller.service.type=LoadBalancer

    - name: Prepare Grafana admin secret (namespace + secret)
      env:
        GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
      run: |
        set -e
        # Ensure monitoring namespace exists (idempotent)
        kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
        # Create or update the admin secret
        PASS="$GRAFANA_ADMIN_PASSWORD"
        if [ -z "$PASS" ]; then
          echo "No GRAFANA_ADMIN_PASSWORD secret provided. Generating a strong password..."
          PASS=$(openssl rand -base64 18)
        fi
        kubectl -n monitoring create secret generic grafana-admin-credentials \
          --from-literal=admin-user=admin \
          --from-literal=admin-password="$PASS" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Install Monitoring via Ansible playbook
      run: |
        set -e
        python3 -V || true
        sudo apt-get update -y
        sudo apt-get install -y python3-pip
        pip3 install --user ansible kubernetes openshift pyyaml
        ~/.local/bin/ansible-galaxy collection install kubernetes.core
        # Run the playbook against localhost using existing kubeconfig
        ~/.local/bin/ansible-playbook -i localhost, -c local deploy-monitoring.yml

    - name: Show Monitoring Access Info
      run: |
        # Print Grafana external IP if available
        GIP=$(kubectl get svc grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
        if [ -n "$GIP" ]; then
          echo "Grafana is reachable at: http://$GIP"
          echo "Credentials -> user: admin | password: (from secret grafana-admin-credentials)"
        else
          echo "Grafana LoadBalancer IP pending. Check later with: kubectl get svc grafana -n monitoring"
        fi
    
    - name: Deploy App
      run: |
        kubectl create namespace devops-advisor --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret generic app-secret \
          --from-literal=OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
          --from-literal=FLASK_SECRET_KEY="${{ secrets.FLASK_SECRET_KEY }}" \
          -n devops-advisor --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret generic postgres-secret \
          --from-literal=POSTGRES_USER="postgres" \
          --from-literal=POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
          --from-literal=POSTGRES_DB="devops_advisor_db" \
          -n devops-advisor --dry-run=client -o yaml | kubectl apply -f -
        sed -i 's|devopsaacr.azurecr.io|group6acr.azurecr.io|g' k8s_solution/api-deploy.yml
        kubectl apply -f k8s_solution/
        kubectl wait --namespace devops-advisor --for=condition=ready pod -l app=postgres --timeout=300s || true
        kubectl wait --namespace devops-advisor --for=condition=ready pod -l app=devops-advisor --timeout=300s || true

    - name: Enable AGIC (Application Gateway Ingress Controller)
      run: |
        set -e
        echo "Checking if AGIC addon is already enabled..."
        ENABLED=$(az aks show -g rg-devops-group6 -n devopsa-aks --query "addonProfiles.ingressApplicationGateway.enabled" -o tsv || echo "false")
        if [ "$ENABLED" = "true" ]; then
          echo "AGIC already enabled. Skipping."
        else
          echo "Enabling AGIC addon..."
          az aks enable-addons \
            -a ingress-appgw \
            -n devopsa-aks \
            -g rg-devops-group6 \
            --appgw-name myAppGwG6 \
            --appgw-subnet-cidr "10.225.0.0/16"
          echo "AGIC enabled."
        fi

    - name: Restart app after AGIC and wait
      run: |
        set -e
        kubectl rollout restart deployment/devops-advisor-app -n devops-advisor
        kubectl rollout status deployment/devops-advisor-app -n devops-advisor --timeout=300s

        # Optional: wait for AGIC to provision public IP
        for i in {1..20}; do
          IP=$(kubectl -n devops-advisor get ingress devops-advisor-agic -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
          if [ -n "$IP" ]; then
            echo "AGIC public IP: $IP"
            break
          fi
          echo "Waiting for AGIC IP..."
          sleep 15
        done
    
    - name: Get Application Status (AGIC Ingress)
      run: |
        echo " DEPLOYMENT COMPLETED SUCCESSFULLY!"
        echo ""
        echo " Waiting for AGIC Ingress IP assignment..."
        for i in {1..20}; do
          INGRESS_IP=$(kubectl -n devops-advisor get ingress devops-advisor-agic -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -n "$INGRESS_IP" ]; then
            break
          fi
          echo "Attempt $i: Still waiting for AGIC IP..."
          sleep 10
        done
        echo "════════════════════════════════════════"
        if [ -n "$INGRESS_IP" ]; then
          echo " YOUR APPLICATION IS LIVE VIA APPLICATION GATEWAY!"
          echo ""
          echo "    URL: http://$INGRESS_IP"
          echo "    Access your DevOps Advisor app now!"
          echo ""
        else
          echo " AGIC Ingress IP not available yet."
          echo "   Check later with: kubectl -n devops-advisor get ingress devops-advisor-agic -o wide"
          echo ""
        fi
        echo " APPLICATION STATUS:"
        kubectl get pods -n devops-advisor
        echo ""
        echo " APPLICATION HEALTH CHECK (recent logs):"
        kubectl logs -n devops-advisor -l app=devops-advisor --tail=50 || true
        echo "════════════════════════════════════════"
        echo " DEPLOYMENT SUCCESSFUL!"