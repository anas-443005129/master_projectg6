name: Simple DevOps CI/CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Build and Push
      run: |
        docker build -t group6acr.azurecr.io/devops-advisor:latest .
        az acr login --name group6acr
        docker push group6acr.azurecr.io/devops-advisor:latest
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
    
    - name: Terraform Apply
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      run: |
        set -e
        # Extract values from AZURE_CREDENTIALS and export as ARM variables
        export ARM_CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
        export ARM_CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
        export ARM_SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
        export ARM_TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
        export TF_IN_AUTOMATION=true
        export TF_INPUT=false

        # Backend details (match providers.tf)
        export TFSTATE_RG="Group-6"
        export TFSTATE_SA="group6sa"
        export TFSTATE_CONTAINER="tfstate"
        export TFSTATE_BLOB="terraform.tfstate"

        # Ensure subscription context
        az account set --subscription "$ARM_SUBSCRIPTION_ID"

        # Use account key for reliable data-plane control (avoids RBAC gaps)
        SA_KEY=$(az storage account keys list -g "$TFSTATE_RG" -n "$TFSTATE_SA" --query "[0].value" -o tsv)
        break_lease_and_wait() {
          # Requires SA_KEY and TFSTATE_* env vars
          if [ -z "$SA_KEY" ]; then
            echo "Warning: storage account key unavailable; cannot break lease explicitly"
            return 0
          fi
          for i in 1 2 3 4 5 6; do
            CUR=$(az storage blob show \
              --account-name "$TFSTATE_SA" \
              --container-name "$TFSTATE_CONTAINER" \
              --name "$TFSTATE_BLOB" \
              --account-key "$SA_KEY" \
              --query 'properties.lease.state' -o tsv 2>/dev/null || echo "")
            echo "Lease state: ${CUR:-unknown}"
            if [ "$CUR" != "leased" ]; then
              break
            fi
            echo "Breaking active lease on tfstate blob... (attempt $i)"
            az storage blob lease break \
              --account-name "$TFSTATE_SA" \
              --container-name "$TFSTATE_CONTAINER" \
              --blob-name "$TFSTATE_BLOB" \
              --account-key "$SA_KEY" || true
            sleep 10
          done
          # Final check
          FINAL=$(az storage blob show \
            --account-name "$TFSTATE_SA" \
            --container-name "$TFSTATE_CONTAINER" \
            --name "$TFSTATE_BLOB" \
            --account-key "$SA_KEY" \
            --query 'properties.lease.state' -o tsv 2>/dev/null || echo "")
          echo "Final lease state: ${FINAL:-unknown}"
        }

        break_lease_and_wait

        cd terraform
        terraform init -upgrade
        break_lease_and_wait
        DESIRED_RG="rg-devops-group6"
        CURRENT_RG=$(terraform state show module.resourcegroups.azurerm_resource_group.this 2>/dev/null | awk -F' = ' '/^\s*name\s*=/{print $2}' | head -n1 || true)
        echo "Desired RG: $DESIRED_RG | State RG: ${CURRENT_RG:-none}"
        if [ -n "$CURRENT_RG" ] && [ "$CURRENT_RG" != "$DESIRED_RG" ]; then
          echo "State references a different RG ($CURRENT_RG). Removing it from state to avoid deletion..."
          terraform state rm module.resourcegroups.azurerm_resource_group.this || true
        fi
        export TF_LOG=ERROR
        export TF_LOG_PATH=./tf.log
        terraform apply -auto-approve -lock-timeout=5m \
          -var="ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID" \
          -var="resource_group_name=rg-devops-group6" \
          -var="resource_group_location=polandcentral" \
          -var="resource_prefix=devopsa" \
          -var="environment=dev" \
          -var="managed_disk_name=app-data" \
          -var="disk_size_gb=20" \
          -var="storage_account_type=Standard_LRS" \
          -var="author=group6"
    
    - name: Setup AKS
      run: |
        az aks get-credentials --resource-group rg-devops-group6 --name devopsa-aks
        az aks update -n devopsa-aks -g rg-devops-group6 --attach-acr group6acr
    
    - name: Setup Helm (for ingress and monitoring)
      uses: azure/setup-helm@v4

    - name: Install Argo CD via Ansible playbook
      run: |
        set -e
        python3 -V || true
        sudo apt-get update -y
        sudo apt-get install -y python3-pip
        pip3 install --user ansible kubernetes openshift pyyaml
        ~/.local/bin/ansible-galaxy collection install kubernetes.core
        ~/.local/bin/ansible-playbook -i localhost, -c local deploy-argocd.yml

    - name: Show Argo CD Access Info
      run: |
        set -e
        kubectl -n argocd get pods
        ARGO_IP=$(kubectl -n argocd get svc argocd-server -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
        if [ -n "$ARGO_IP" ]; then
          echo "Argo CD UI: http://$ARGO_IP"
          echo "Initial admin password (one-time):"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d || true
          echo
        else
          echo "Argo CD LoadBalancer IP pending. Check later with: kubectl -n argocd get svc argocd-server"
        fi

    - name: Install ingress-nginx via Helm (idempotent)
      run: |
        set -e
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx || true
        helm repo update
        # Install/upgrade NGINX Ingress Controller; safe to re-run
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --set controller.service.type=LoadBalancer

    - name: Prepare Grafana admin secret (namespace + secret)
      env:
        GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
      run: |
        set -e
        # Ensure monitoring namespace exists (idempotent)
        kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
        # Create or update the admin secret
        PASS="$GRAFANA_ADMIN_PASSWORD"
        if [ -z "$PASS" ]; then
          echo "No GRAFANA_ADMIN_PASSWORD secret provided. Generating a strong password..."
          PASS=$(openssl rand -base64 18)
        fi
        kubectl -n monitoring create secret generic grafana-admin-credentials \
          --from-literal=admin-user=admin \
          --from-literal=admin-password="$PASS" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Install Monitoring via Ansible playbook
      run: |
        set -e
        python3 -V || true
        sudo apt-get update -y
        sudo apt-get install -y python3-pip
        pip3 install --user ansible kubernetes openshift pyyaml
        ~/.local/bin/ansible-galaxy collection install kubernetes.core
        # Run the playbook against localhost using existing kubeconfig
        ~/.local/bin/ansible-playbook -i localhost, -c local deploy-monitoring.yml

    - name: Show Monitoring Access Info
      run: |
        # Print Grafana external IP if available
        GIP=$(kubectl get svc grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
        if [ -n "$GIP" ]; then
          echo "Grafana is reachable at: http://$GIP"
          echo "Credentials -> user: admin | password: (from secret grafana-admin-credentials)"
        else
          echo "Grafana LoadBalancer IP pending. Check later with: kubectl get svc grafana -n monitoring"
        fi
    
    - name: Prepare App namespace and secrets (Argo CD will deploy manifests)
      run: |
        kubectl create namespace devops-advisor --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret generic app-secret \
          --from-literal=OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
          --from-literal=FLASK_SECRET_KEY="${{ secrets.FLASK_SECRET_KEY }}" \
          -n devops-advisor --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret generic postgres-secret \
          --from-literal=POSTGRES_USER="postgres" \
          --from-literal=POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
          --from-literal=POSTGRES_DB="devops_advisor_db" \
          -n devops-advisor --dry-run=client -o yaml | kubectl apply -f -

    - name: Create/Update Argo CD Applications
      run: |
        set -e
        kubectl apply -f argocd-apps.yaml
        # Wait for Application to reach Synced/Healthy (best-effort)
        for i in {1..30}; do
          PHASE=$(kubectl -n argocd get application devops-advisor-app -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "")
          HEALTH=$(kubectl -n argocd get application devops-advisor-app -o jsonpath='{.status.health.status}' 2>/dev/null || echo "")
          echo "Argo App Sync=$PHASE Health=$HEALTH"
          if [ "$PHASE" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
            break
          fi
          sleep 10
        done

    - name: Enable AGIC (Application Gateway Ingress Controller)
      run: |
        set -e
        echo "Checking if AGIC addon is already enabled..."
        ENABLED=$(az aks show -g rg-devops-group6 -n devopsa-aks --query "addonProfiles.ingressApplicationGateway.enabled" -o tsv || echo "false")
        if [ "$ENABLED" = "true" ]; then
          echo "AGIC already enabled. Skipping."
        else
          echo "Enabling AGIC addon..."
          az aks enable-addons \
            -a ingress-appgw \
            -n devopsa-aks \
            -g rg-devops-group6 \
            --appgw-name myAppGwG6 \
            --appgw-subnet-cidr "10.225.0.0/16"
          echo "AGIC enabled."
        fi

    - name: Restart app after AGIC and wait
      run: |
        set -e
        kubectl rollout restart deployment devops-advisor-app -n devops-advisor

       
    